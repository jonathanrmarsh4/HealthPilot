{
  "bundle_name": "Structured Workouts Migration ‚Ä¢ One-Paste Orchestration",
  "version": "1.0.0",
  "updated_at": "2025-10-24",
  "goal": "Replace all fuzzy exercise-name matching with a single structured, template-driven pipeline; refactor every dependent algorithm to use it; delete obsolete code; verify the cleanup automatically.",
  "phases": {
    "phase_1_master_migration": {
      "task": "Migrate the workout generation pipeline to StructuredWorkoutsKit and delete obsolete fuzzy-matching code.",
      "instructions": [
        "1Ô∏è‚É£ Replace the entire existing exercise resolution system (exercise-resolver.ts, alias maps, fuzzy logic, normalization pipelines, similarity scoring, tests) with StructuredWorkoutsKit (code provided in `code.structured_workouts_kit_ts`).",
        "2Ô∏è‚É£ Integrate it as the ONLY source of truth for workout generation and validation.",
        "3Ô∏è‚É£ Remove or disable all code paths that reference or import:\n   ‚Ä¢ exercise-resolver.ts / exercise-resolver.v2 / exercise-resolver.v3\n   ‚Ä¢ fuzzy utilities (levenshtein, jaccard, tokenizers)\n   ‚Ä¢ static alias maps / EXPAND tables / normalization pipelines\n   ‚Ä¢ old tests referencing fuzzy matching",
        "4Ô∏è‚É£ Update workout generator (e.g., server/services/trainingGenerator.ts) to use:\n   const kit = StructuredWorkoutsKit();\n   const prompt = kit.buildPrompt();\n   // call LLM...\n   const result = kit.parseAndMap(llmJson, userEquipment, rules);\n   // render from result.plan.blocks",
        "5Ô∏è‚É£ Connect the AI workout generation endpoint to use `kit.buildPrompt()` (strict JSON, no prose).",
        "6Ô∏è‚É£ Validate E2E: ‚ÄúLeg Press 4√ó10; Sauna 15m + Ice Bath 5m√ó3‚Äù yields structured blocks and maps to a concrete exercise_id via rules (no fuzzy).",
        "7Ô∏è‚É£ Delete redundant files:\n   ‚Ä¢ /server/services/exercise-resolver*.ts\n   ‚Ä¢ /server/services/normalization-utils*.ts\n   ‚Ä¢ tests that reference fuzzy matchers\n   ‚Ä¢ any old JSON configs for aliases/normalization",
        "8Ô∏è‚É£ Clean configs/ENV: remove keys like EXERCISE_RESOLVER_V2, FUZZY_MATCH_THRESHOLD, AUTO_ALIAS, etc.",
        "9Ô∏è‚É£ Add the new file `/server/services/structured-workouts-kit.ts` with the exact code from `code.structured_workouts_kit_ts`."
      ]
    },
    "phase_2_full_integration": {
      "task": "Refactor and re-wire ALL algorithms that depend on exercise/workout data to use StructuredWorkoutsKit.",
      "scope": [
        "AI workout generator / planner",
        "Readiness-based session builder",
        "Daily insights/summary generation (anything that reads or writes workouts)",
        "Workout acceptance & tracker modules",
        "User preferences (equipment, limitations, goals)",
        "Training analytics (volume, intensity, pattern distribution)"
      ],
      "instructions": [
        "1Ô∏è‚É£ Search the repo for any function that consumes or produces exercise/workout data (e.g., trainingGenerator.ts, workoutPlanner.ts, workoutTracker.ts, WorkoutBuilder components, Insights).",
        "2Ô∏è‚É£ For each algorithm found, rewrite I/O to use the StructuredWorkoutsKit schema:\n   ‚Ä¢ Input: structured JSON blocks validated by `kit.parseAndMap()`\n   ‚Ä¢ Output: same structured JSON with resolved `exercise_id` (no name strings).",
        "3Ô∏è‚É£ Remove references to obsolete entities:\n   ‚Ä¢ resolveExerciseName / matchExerciseToLibrary\n   ‚Ä¢ exerciseTypeGuesser / exerciseNormalizer\n   ‚Ä¢ fuzzyResolve / aliasLookup\n   ‚Ä¢ any hardcoded exercise_name usage (use exercise_id or pattern+modality)",
        "4Ô∏è‚É£ Update readiness/training algorithms to select exercises by `pattern` + available `equipment` via the selector inside StructuredWorkoutsKit.",
        "5Ô∏è‚É£ Ensure all AI prompts for workouts use `kit.buildPrompt()` (strict JSON-only).",
        "6Ô∏è‚É£ Modify the workout tracker UI:\n   ‚Ä¢ Read from `block.exercise_id` and display the mapped DB name\n   ‚Ä¢ Support non-lift blocks (recovery_cycle, endurance_block, mobility_block)\n   ‚Ä¢ Remove client-side normalizers/fuzzy logic",
        "7Ô∏è‚É£ Update analytics:\n   ‚Ä¢ Volume: sets√óreps for LiftBlock\n   ‚Ä¢ Endurance: distance_m or duration_s\n   ‚Ä¢ Recovery: total duration per cycle\n   ‚Ä¢ Mobility: total time\n   Ensure all read the unified structured schema.",
        "8Ô∏è‚É£ Delete legacy helpers/tests tied to old resolver (normalizeExerciseName.ts, exerciseMatchHelpers.ts, related tests).",
        "9Ô∏è‚É£ Update types (global/@types): replace old Exercise types with StructuredWorkoutsKit `AnyBlock` shapes.",
        "üîü Run the verification script (in `code.verification_script_js`) to ensure no fuzzy references remain."
      ]
    }
  },
  "acceptance_criteria": [
    "‚Ä¢ All workouts are generated through StructuredWorkoutsKit only.",
    "‚Ä¢ No file in the codebase references fuzzy resolver logic or raw exercise names.",
    "‚Ä¢ LLM prompt uses strict JSON schema; server validates with `parseAndMap`.",
    "‚Ä¢ Unit tests exist for `parseAndMap` and rules-based `exercise_id` mapping.",
    "‚Ä¢ Readiness/planner/insights/tracker/analytics all consume the unified schema.",
    "‚Ä¢ Verification script reports PASS (no legacy references found)."
  ],
  "runbook": [
    "1) Create /server/services/structured-workouts-kit.ts with the code below.",
    "2) Wire the generator to use `kit.buildPrompt()` and parse with `kit.parseAndMap()`.",
    "3) Define rules mapping (pattern+modality ‚Üí exercise_id) from your DB/config.",
    "4) Remove fuzzy resolver files, aliases, and tests.",
    "5) Refactor dependent modules to use structured blocks.",
    "6) Run `node scripts/verify_structured_workouts_migration.js`.",
    "7) Commit: 'refactor: migrate to StructuredWorkoutsKit and remove fuzzy resolver'."
  ],
  "code": {
    "structured_workouts_kit_ts": "// structured-workouts-kit.ts\n// One function to rule them all: prompt + validate + map ‚Üí exercise_ids (no fuzzy matching).\n\nexport function StructuredWorkoutsKit() {\n  // ----- ENUMS (app language the AI must speak) -----\n  const MovementPattern = [\n    \"knee_dominant\",\"hip_hinge\",\"horizontal_press\",\"horizontal_pull\",\n    \"vertical_press\",\"vertical_pull\",\"lunge_split\",\"core_anti_ext\",\n    \"core_anti_rot\",\"carry\",\"calf\",\"biceps\",\"triceps\",\"shoulder_iso\",\n    \"hamstrings_iso\",\"glute_iso\"\n  ] as const;\n\n  const Modality = [\n    \"barbell\",\"dumbbell\",\"kettlebell\",\"machine\",\"cable\",\n    \"bodyweight\",\"band\",\"landmine\",\"smith\"\n  ] as const;\n\n  const EnduranceModality = [\"run\",\"row\",\"swim\",\"bike\",\"ski\"] as const;\n\n  type Pattern = typeof MovementPattern[number];\n  type Mod = typeof Modality[number];\n  type EndMod = typeof EnduranceModality[number];\n\n  // ----- LLM PROMPT (strict JSON-only, no prose) -----\n  function buildPrompt(example?: { blocks?: any[]; notes?: string; }) {\n    const schema = {\n      WorkoutPlan: { blocks: [\"LiftBlock | EnduranceBlock | RecoveryCycle | MobilityBlock\"] },\n      LiftBlock: {\n        type: \"lift_block\",\n        pattern: MovementPattern,\n        preferred_modality: Modality,\n        sets: \"int 1..8\",\n        reps: \"int 1..25 OR [min,max]\",\n        rest_s: \"int 30..600 (optional)\",\n        intensity: '{ scheme: \"rir\"|\"rpe\"|\"percent1rm\", target: number } (optional)',\n        notes: \"string (optional)\"\n      },\n      EnduranceBlock: {\n        type: \"endurance_block\",\n        modality: EnduranceModality,\n        primary: [\"distance_m\",\"duration_s\"],\n        value: \"number > 0\",\n        intensity: [\"easy\",\"moderate\",\"threshold\",\"interval\"],\n        intervals: \"[{ work_s, rest_s, reps }]* optional\"\n      },\n      RecoveryCycle: {\n        type: \"recovery_cycle\",\n        rounds: \"int 1..10\",\n        steps: \"[{ label: string, duration_s: int 10..3600 } 1..6]\"\n      },\n      MobilityBlock: {\n        type: \"mobility_block\",\n        drills: \"[{ label: string, duration_s: 20..300, reps?: 1..5 } 1..N]\"\n      }\n    };\n\n    const exampleJson = JSON.stringify(\n      example?.blocks?.length\n        ? { blocks: example.blocks }\n        : {\n            blocks: [\n              { type:\"lift_block\", pattern:\"knee_dominant\", preferred_modality:\"machine\", sets:4, reps:10, rest_s:120 },\n              { type:\"recovery_cycle\", rounds:3, steps:[{label:\"sauna\",duration_s:900},{label:\"ice_bath\",duration_s:300}] }\n            ]\n          },\n      null, 2\n    );\n\n    return [\n      \"You must output ONLY valid JSON. No prose, no markdown, no comments.\",\n      \"Use the following schema exactly:\",\n      JSON.stringify(schema, null, 2),\n      \"\",\n      \"Output shape:\",\n      \"{ \\\"blocks\\\": (LiftBlock | EnduranceBlock | RecoveryCycle | MobilityBlock)[] }\",\n      \"\",\n      \"Example:\",\n      exampleJson\n    ].join(\"\\n\");\n  }\n\n  // ----- RUNTIME VALIDATOR (no deps) -----\n  type LiftBlock = {\n    type: \"lift_block\";\n    pattern: Pattern;\n    preferred_modality?: Mod;\n    sets: number;\n    reps: number | [number, number];\n    rest_s?: number;\n    intensity?: { scheme?: \"rir\"|\"rpe\"|\"percent1rm\"; target?: number };\n    notes?: string;\n    label?: string;\n  };\n  type EnduranceBlock = {\n    type: \"endurance_block\";\n    modality: EndMod;\n    primary: \"distance_m\"|\"duration_s\";\n    value: number;\n    intensity?: \"easy\"|\"moderate\"|\"threshold\"|\"interval\";\n    intervals?: { work_s:number; rest_s:number; reps:number }[];\n    label?: string;\n  };\n  type RecoveryCycle = { type: \"recovery_cycle\"; rounds: number; steps: { label: string; duration_s: number }[] };\n  type MobilityBlock = { type: \"mobility_block\"; drills: { label: string; duration_s: number; reps?: number }[] };\n  type AnyBlock = LiftBlock | EnduranceBlock | RecoveryCycle | MobilityBlock;\n\n  function isEnum<T extends readonly string[]>(val: any, arr: T): val is T[number] {\n    return typeof val === \"string\" && (arr as readonly string[]).includes(val);\n  }\n  const isInt = (n: any) => Number.isInteger(n);\n  const isNum = (n: any) => typeof n === \"number\" && Number.isFinite(n);\n\n  function validatePlan(raw: any): { ok: true; blocks: AnyBlock[] } | { ok: false; errors: string[] } {\n    const errors: string[] = [];\n    if (!raw || typeof raw !== \"object\") return { ok:false, errors:[\"Root must be an object\"] };\n    if (!Array.isArray(raw.blocks)) return { ok:false, errors:[\"blocks must be an array\"] };\n\n    const blocks: AnyBlock[] = [];\n    raw.blocks.forEach((b: any, i: number) => {\n      if (!b || typeof b !== \"object\") { errors.push(`blocks[${i}] must be object`); return; }\n      if (b.type === \"lift_block\") {\n        const { pattern, preferred_modality, sets, reps, rest_s, intensity } = b;\n        if (!isEnum(pattern, MovementPattern)) errors.push(`blocks[${i}].pattern invalid`);\n        if (preferred_modality && !isEnum(preferred_modality, Modality)) errors.push(`blocks[${i}].preferred_modality invalid`);\n        if (!isInt(sets) || sets < 1 || sets > 8) errors.push(`blocks[${i}].sets 1..8`);\n        const repsOk = (isInt(reps) && reps >=1 && reps <=25) || (Array.isArray(reps) && reps.length===2 && reps.every(isInt) && reps[0]>=1 && reps[1]<=25 && reps[0]<=reps[1]);\n        if (!repsOk) errors.push(`blocks[${i}].reps invalid`);\n        if (rest_s !== undefined && (!isInt(rest_s) || rest_s < 30 || rest_s > 600)) errors.push(`blocks[${i}].rest_s 30..600`);\n        if (intensity && typeof intensity !== \"object\") errors.push(`blocks[${i}].intensity invalid`);\n        blocks.push(b as LiftBlock);\n      } else if (b.type === \"endurance_block\") {\n        const { modality, primary, value, intensity, intervals } = b;\n        if (!isEnum(modality, EnduranceModality)) errors.push(`blocks[${i}].modality invalid`);\n        if (primary !== \"distance_m\" && primary !== \"duration_s\") errors.push(`blocks[${i}].primary invalid`);\n        if (!isNum(value) || value <= 0) errors.push(`blocks[${i}].value > 0`);\n        if (intensity && ![\"easy\",\"moderate\",\"threshold\",\"interval\"].includes(intensity)) errors.push(`blocks[${i}].intensity invalid`);\n        if (intervals) {\n          if (!Array.isArray(intervals)) errors.push(`blocks[${i}].intervals must be array`);\n          else intervals.forEach((it, k) => {\n            if (!isInt(it.work_s) || !isInt(it.rest_s) || !isInt(it.reps) || it.work_s<=0 || it.rest_s<0 || it.reps<1)\n              errors.push(`blocks[${i}].intervals[${k}] invalid`);\n          });\n        }\n        blocks.push(b as EnduranceBlock);\n      } else if (b.type === \"recovery_cycle\") {\n        const { rounds, steps } = b;\n        if (!isInt(rounds) || rounds < 1 || rounds > 10) errors.push(`blocks[${i}].rounds 1..10`);\n        if (!Array.isArray(steps) || steps.length < 1 || steps.length > 6) errors.push(`blocks[${i}].steps 1..6`);\n        else steps.forEach((s, k) => {\n          if (!s || typeof s !== \"object\" || typeof s.label !== \"string\" || !isInt(s.duration_s) || s.duration_s < 10 || s.duration_s > 3600)\n            errors.push(`blocks[${i}].steps[${k}] invalid`);\n        });\n        blocks.push(b as RecoveryCycle);\n      } else if (b.type === \"mobility_block\") {\n        const { drills } = b;\n        if (!Array.isArray(drills) || drills.length < 1) errors.push(`blocks[${i}].drills missing`);\n        else drills.forEach((d, k) => {\n          const repsOk = d.reps === undefined || (isInt(d.reps) && d.reps >= 1 && d.reps <= 5);\n          if (!d || typeof d !== \"object\" || typeof d.label !== \"string\" || !isInt(d.duration_s) || d.duration_s < 20 || d.duration_s > 300 || !repsOk)\n            errors.push(`blocks[${i}].drills[${k}] invalid`);\n        });\n        blocks.push(b as MobilityBlock);\n      } else {\n        errors.push(`blocks[${i}].type must be one of lift_block|endurance_block|recovery_cycle|mobility_block`);\n      }\n    });\n\n    return errors.length ? { ok:false, errors } : { ok:true, blocks };\n  }\n\n  // ----- SELECTOR (pattern + modality + equipment -> exercise_id) -----\n  type Equipment = Mod[];\n  type Rules = Record<Pattern, Partial<Record<Mod, string>>>;\n\n  function chooseExerciseId(\n    block: AnyBlock,\n    equipment: Equipment,\n    rules: Rules\n  ): { exercise_id?: string; reason: string } {\n    if (block.type !== \"lift_block\") return { reason: \"non-lift block\" };\n\n    const prefs = [block.preferred_modality, \"machine\",\"barbell\",\"dumbbell\",\"bodyweight\",\"cable\",\"kettlebell\",\"smith\",\"landmine\",\"band\"]\n      .filter(Boolean) as Mod[];\n    const avail = prefs.find(m => equipment.includes(m));\n    if (!avail) return { reason: `no available modality for pattern=${block.pattern}` };\n\n    const id = rules[block.pattern]?.[avail];\n    return id\n      ? { exercise_id: id, reason: `pattern=${block.pattern} via ${avail}` }\n      : { reason: `no mapping for pattern=${block.pattern} with ${avail}` };\n  }\n\n  // ----- PUBLIC: validate + map end-to-end -----\n  function parseAndMap(\n    rawJson: string | Record<string, any>,\n    equipment: Equipment,\n    rules: Rules\n  ): { ok: true; plan: { blocks: (AnyBlock & { exercise_id?: string })[] }; warnings: string[] }\n     | { ok: false; errors: string[]; promptHint: string } {\n    let parsed: any;\n    try { parsed = typeof rawJson === \"string\" ? JSON.parse(rawJson) : rawJson; }\n    catch (e) { return { ok:false, errors:[`Invalid JSON: ${String(e)}`], promptHint: buildPrompt() }; }\n\n    const v = validatePlan(parsed);\n    if (!v.ok) return { ok:false, errors:v.errors, promptHint: buildPrompt() };\n\n    const warnings: string[] = [];\n    const mappedBlocks = v.blocks.map(b => {\n      if (b.type !== \"lift_block\") return b;\n      const pick = chooseExerciseId(b, equipment, rules);\n      if (!pick.exercise_id) warnings.push(pick.reason);\n      return { ...b, exercise_id: pick.exercise_id };\n    });\n\n    return { ok:true, plan:{ blocks: mappedBlocks }, warnings };\n  }\n\n  // ----- EXPORTS -----\n  return {\n    buildPrompt,\n    parseAndMap,\n    enums: { MovementPattern, Modality, EnduranceModality }\n  };\n}\n",
    "verification_script_js": "// scripts/verify_structured_workouts_migration.js\n// Run: node scripts/verify_structured_workouts_migration.js\n// Purpose: Ensure no fuzzy resolver code remains; StructuredWorkoutsKit is present and referenced.\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst ROOT = process.cwd();\nconst TARGET_FILE = path.join(ROOT, 'server', 'services', 'structured-workouts-kit.ts');\n\nconst FORBIDDEN_PATTERNS = [\n  /resolveExerciseName\\b/i,\n  /exercise-resolver(\\.v\\d+)?\\.ts/i,\n  /levenshtein\\b/i,\n  /jaccard\\b/i,\n  /fuzzy\\b/i,\n  /aliasLookup\\b/i,\n  /normalizeExercise(Name|s)?\\b/i,\n  /STATIC_ALIASES\\b/i,\n  /EXPAND\\b/i\n];\n\nfunction walk(dir) {\n  let results = [];\n  const list = fs.readdirSync(dir, { withFileTypes: true });\n  for (const f of list) {\n    if (f.name.startsWith('.') || ['node_modules','.git','.next','dist','build'].includes(f.name)) continue;\n    const p = path.join(dir, f.name);\n    if (f.isDirectory()) results = results.concat(walk(p));\n    else if (f.isFile()) results.push(p);\n  }\n  return results;\n}\n\nfunction scanFile(file) {\n  const txt = fs.readFileSync(file, 'utf8');\n  const hits = FORBIDDEN_PATTERNS.filter(rx => rx.test(txt)).map(rx => rx.source);\n  return { file, hits };\n}\n\nfunction main() {\n  const all = walk(ROOT).filter(p => /\\.(ts|tsx|js|jsx|json)$/.test(p));\n  const offenders = [];\n  for (const f of all) {\n    const { hits } = scanFile(f);\n    if (hits.length) offenders.push({ file: f, hits });\n  }\n\n  const kitExists = fs.existsSync(TARGET_FILE);\n\n  // Heuristic: ensure at least one server file imports/uses the kit\n  const kitUsage = all\n    .filter(f => /\\.(ts|tsx|js)$/.test(f))\n    .map(f => ({ f, txt: fs.readFileSync(f, 'utf8') }))\n    .filter(({ txt }) => /StructuredWorkoutsKit/.test(txt) && /buildPrompt|parseAndMap/.test(txt))\n    .map(({ f }) => f);\n\n  console.log('--- Structured Workouts Migration Verification ---');\n  console.log('StructuredWorkoutsKit file present:', kitExists ? 'YES' : 'NO');\n  if (!kitExists) console.log('Expected at:', TARGET_FILE);\n\n  if (offenders.length) {\n    console.log('\\n‚ùå Found legacy fuzzy resolver references:');\n    offenders.slice(0, 50).forEach(o => {\n      console.log('-', o.file);\n      console.log('  hits:', o.hits.join(', '));\n    });\n  } else {\n    console.log('\\n‚úÖ No legacy fuzzy references detected.');\n  }\n\n  if (kitUsage.length) {\n    console.log('\\n‚úÖ StructuredWorkoutsKit appears to be used in:');\n    kitUsage.slice(0, 50).forEach(f => console.log('-', f));\n  } else {\n    console.log('\\n‚ö†Ô∏è Could not detect usage of StructuredWorkoutsKit. Ensure generator/planner call:');\n    console.log('   const kit = StructuredWorkoutsKit();');\n    console.log('   const prompt = kit.buildPrompt();');\n    console.log('   const result = kit.parseAndMap(llmJson, equipment, rules);');\n  }\n\n  const pass = kitExists && offenders.length === 0 && kitUsage.length > 0;\n  console.log('\\nResult:', pass ? 'PASS ‚úÖ' : 'FAIL ‚ùå');\n  process.exit(pass ? 0 : 1);\n}\n\nmain();\n"
  }
}
