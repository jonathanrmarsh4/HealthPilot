{
  "bundle_name": "HealthPilot • Structured Workouts – Hard Reset E2E",
  "version": "1.0.0",
  "updated_at": "2025-10-24",
  "destructive": true,
  "goal": "Hard-cut to a deterministic, template-driven workout system. Delete fuzzy matching, drop legacy workout data, stand up minimal templates + rules, wire all algorithms to the new flow, and verify end-to-end.",
  "env_flags": {
    "STRUCTURED_WORKOUTS": "on",
    "INSIGHTS_INCLUDE_ALL": "1",
    "INSIGHTS_DYNAMIC_DISCOVERY": "1"
  },
  "scope_of_change": [
    "Delete legacy fuzzy resolver code, aliases, and tests",
    "Drop ALL old workout data (no users exist yet)",
    "Create small `exercise_templates` catalog and a simple `workouts` table",
    "Adopt `StructuredWorkoutsKit` for prompt/validation/mapping",
    "Refactor planner/readiness/insights/tracker to consume structured blocks",
    "Ship RULES mapping for the common patterns × modalities",
    "Add verification + smoke E2E scripts"
  ],

  "cleanup": {
    "delete_files_glob": [
      "server/services/exercise-resolver*.ts",
      "server/services/*normalization*.ts",
      "server/utils/*fuzzy*.ts",
      "tests/**/*resolver*.test.*",
      "tests/**/*fuzzy*.test.*",
      "client/**/*normalize*Exercise*.ts*",
      "config/**/*aliases*.json"
    ],
    "remove_env_keys": [
      "EXERCISE_RESOLVER_V2",
      "FUZZY_MATCH_THRESHOLD",
      "AUTO_ALIAS",
      "RESOLVER_DEBUG"
    ]
  },

  "db": {
    "drop_and_create_sql": "-- HARD RESET – RUN ON EMPTY/NO USERS ENV\n-- 1) Drop legacy workout tables if present\nDROP TABLE IF EXISTS workout_history CASCADE;\nDROP TABLE IF EXISTS workout_exercises CASCADE;\nDROP TABLE IF EXISTS workout_blocks CASCADE;\nDROP TABLE IF EXISTS workouts CASCADE;\n\n-- 2) Minimal enums\nDO $$ BEGIN\n  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'pattern') THEN\n    CREATE TYPE pattern AS ENUM (\n      'knee_dominant','hip_hinge','horizontal_press','horizontal_pull',\n      'vertical_press','vertical_pull','lunge_split','core_anti_ext',\n      'core_anti_rot','carry','calf','biceps','triceps','shoulder_iso',\n      'hamstrings_iso','glute_iso'\n    );\n  END IF;\n  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'modality') THEN\n    CREATE TYPE modality AS ENUM (\n      'barbell','dumbbell','kettlebell','machine','cable','bodyweight','band','landmine','smith'\n    );\n  END IF;\n  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'angle') THEN\n    CREATE TYPE angle AS ENUM ('flat','incline','decline','neutral');\n  END IF;\nEND $$;\n\n-- 3) New tiny catalog for renderable choices\nCREATE TABLE IF NOT EXISTS exercise_templates (\n  id              TEXT PRIMARY KEY,\n  pattern         pattern NOT NULL,\n  modality        modality NOT NULL,\n  angle           angle NOT NULL DEFAULT 'neutral',\n  unilateral      BOOLEAN NOT NULL DEFAULT FALSE,\n  assisted        BOOLEAN NOT NULL DEFAULT FALSE,\n  display_name    TEXT NOT NULL,\n  media_url       TEXT,\n  coaching_cues   TEXT[] DEFAULT '{}',\n  UNIQUE (pattern, modality, angle, unilateral, assisted)\n);\n\n-- 4) New workouts table storing structured JSON plans\nCREATE TABLE IF NOT EXISTS workouts (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL,\n  date DATE NOT NULL,\n  plan JSONB NOT NULL,             -- StructuredWorkoutsKit JSON\n  created_at TIMESTAMPTZ DEFAULT now(),\n  updated_at TIMESTAMPTZ DEFAULT now()\n);\nCREATE INDEX IF NOT EXISTS idx_workouts_user_date ON workouts(user_id, date);\n",
    "seed_templates_sql": "-- Minimal starter templates (expand as needed)\nINSERT INTO exercise_templates (id,pattern,modality,angle,display_name,media_url) VALUES\n  ('tpl_bb_flat_bench','horizontal_press','barbell','flat','Barbell Bench Press',NULL),\n  ('tpl_db_flat_press','horizontal_press','dumbbell','flat','Dumbbell Bench Press',NULL),\n  ('tpl_machine_chest_press','horizontal_press','machine','flat','Machine Chest Press',NULL),\n  ('tpl_lat_pulldown','vertical_pull','cable','neutral','Lat Pulldown',NULL),\n  ('tpl_pullup','vertical_pull','bodyweight','neutral','Pull-Up',NULL),\n  ('tpl_assisted_pullup','vertical_pull','machine','neutral','Assisted Pull-Up',NULL),\n  ('tpl_leg_press','knee_dominant','machine','neutral','Leg Press',NULL),\n  ('tpl_bb_back_squat','knee_dominant','barbell','neutral','Barbell Back Squat',NULL),\n  ('tpl_goblet_squat','knee_dominant','dumbbell','neutral','Goblet Squat',NULL),\n  ('tpl_bb_rdl','hip_hinge','barbell','neutral','Barbell Romanian Deadlift',NULL),\n  ('tpl_db_rdl','hip_hinge','dumbbell','neutral','Dumbbell Romanian Deadlift',NULL),\n  ('tpl_machine_hinge','hip_hinge','machine','neutral','Machine Hip Hinge',NULL)\nON CONFLICT DO NOTHING;\n"
  },

  "code": {
    "structured_workouts_kit_ts": "// structured-workouts-kit.ts\n// Prompt + validate + map → template_ids (no fuzzy matching)\nexport function StructuredWorkoutsKit() {\n  const MovementPattern = [\n    \"knee_dominant\",\"hip_hinge\",\"horizontal_press\",\"horizontal_pull\",\n    \"vertical_press\",\"vertical_pull\",\"lunge_split\",\"core_anti_ext\",\n    \"core_anti_rot\",\"carry\",\"calf\",\"biceps\",\"triceps\",\"shoulder_iso\",\n    \"hamstrings_iso\",\"glute_iso\"\n  ] as const;\n  const Modality = [\n    \"barbell\",\"dumbbell\",\"kettlebell\",\"machine\",\"cable\",\n    \"bodyweight\",\"band\",\"landmine\",\"smith\"\n  ] as const;\n  const EnduranceModality = [\"run\",\"row\",\"swim\",\"bike\",\"ski\"] as const;\n  type Pattern = typeof MovementPattern[number];\n  type Mod = typeof Modality[number];\n  type EndMod = typeof EnduranceModality[number];\n\n  function buildPrompt(example?: { blocks?: any[] }) {\n    const schema = {\n      WorkoutPlan: { blocks: [\"LiftBlock | EnduranceBlock | RecoveryCycle | MobilityBlock\"] },\n      LiftBlock: {\n        type: \"lift_block\", pattern: MovementPattern, preferred_modality: Modality,\n        sets: \"int 1..8\", reps: \"int 1..25 OR [min,max]\", rest_s: \"int 30..600 (optional)\",\n        intensity: '{ scheme: \"rir\"|\"rpe\"|\"percent1rm\", target: number } (optional)', notes: \"string (optional)\"\n      },\n      EnduranceBlock: {\n        type: \"endurance_block\", modality: EnduranceModality, primary: [\"distance_m\",\"duration_s\"],\n        value: \"number > 0\", intensity: [\"easy\",\"moderate\",\"threshold\",\"interval\"],\n        intervals: \"[{ work_s, rest_s, reps }]* optional\"\n      },\n      RecoveryCycle: { type: \"recovery_cycle\", rounds: \"int 1..10\", steps: \"[{ label: string, duration_s: int 10..3600 } 1..6]\" },\n      MobilityBlock: { type: \"mobility_block\", drills: \"[{ label: string, duration_s: 20..300, reps?: 1..5 } 1..N]\" }\n    };\n    const exampleJson = JSON.stringify(\n      example?.blocks?.length ? { blocks: example.blocks } : {\n        blocks: [\n          { type:\"lift_block\", pattern:\"knee_dominant\", preferred_modality:\"machine\", sets:4, reps:10, rest_s:120 },\n          { type:\"recovery_cycle\", rounds:3, steps:[{label:\"sauna\",duration_s:900},{label:\"ice_bath\",duration_s:300}] }\n        ]\n      }, null, 2\n    );\n    return [\n      \"You must output ONLY valid JSON. No prose, no markdown, no comments.\",\n      \"Use the following schema exactly:\", JSON.stringify(schema, null, 2), \"\",\n      \"Output shape:\", \"{ \\\"blocks\\\": (LiftBlock | EnduranceBlock | RecoveryCycle | MobilityBlock)[] }\", \"\",\n      \"Example:\", exampleJson\n    ].join(\"\\n\");\n  }\n\n  type LiftBlock = { type: \"lift_block\"; pattern: Pattern; preferred_modality?: Mod; sets: number; reps: number | [number, number]; rest_s?: number; intensity?: { scheme?: \"rir\"|\"rpe\"|\"percent1rm\"; target?: number }; notes?: string; label?: string; flags?: { unilateral?: boolean; assisted?: boolean; angle?: \"flat\"|\"incline\"|\"decline\"|\"neutral\" } };\n  export type EnduranceBlock = { type: \"endurance_block\"; modality: EndMod; primary: \"distance_m\"|\"duration_s\"; value: number; intensity?: \"easy\"|\"moderate\"|\"threshold\"|\"interval\"; intervals?: { work_s:number; rest_s:number; reps:number }[]; label?: string };\n  export type RecoveryBlock = { type: \"recovery_cycle\"; rounds: number; steps: { label: \"sauna\"|\"ice_bath\"|\"contrast_shower\"|\"breathwork\"|\"stretch\"; duration_s: number }[] };\n  export type MobilityBlock = { type: \"mobility_block\"; drills: { label: string; duration_s: number; reps?: number }[] };\n  type AnyBlock = LiftBlock | EnduranceBlock | RecoveryBlock | MobilityBlock;\n\n  function isEnum<T extends readonly string[]>(v:any, a:T): v is T[number] { return typeof v === \"string\" && (a as readonly string[]).includes(v); }\n  const isInt = (n:any)=>Number.isInteger(n); const isNum=(n:any)=>typeof n===\"number\"&&Number.isFinite(n);\n  function validatePlan(raw:any): { ok:true; blocks:AnyBlock[] }|{ ok:false; errors:string[] }{\n    const e:string[]=[]; if(!raw||typeof raw!==\"object\")return{ok:false,errors:[\"Root must be an object\"]}; if(!Array.isArray(raw.blocks))return{ok:false,errors:[\"blocks must be an array\"]};\n    const blocks:AnyBlock[]=[]; raw.blocks.forEach((b:any,i:number)=>{ if(!b||typeof b!==\"object\"){e.push(`blocks[${i}] must be object`);return;}\n      if(b.type===\"lift_block\"){ const {pattern,preferred_modality,sets,reps,rest_s,intensity}=b; if(!isEnum(pattern,MovementPattern))e.push(`blocks[${i}].pattern invalid`);\n        if(preferred_modality&&!isEnum(preferred_modality,Modality))e.push(`blocks[${i}].preferred_modality invalid`);\n        if(!isInt(sets)||sets<1||sets>8)e.push(`blocks[${i}].sets 1..8`);\n        const repsOk=(isInt(reps)&&reps>=1&&reps<=25)||(Array.isArray(reps)&&reps.length===2&&reps.every(isInt)&&reps[0]>=1&&reps[1]<=25&&reps[0]<=reps[1]);\n        if(!repsOk)e.push(`blocks[${i}].reps invalid`); if(rest_s!==undefined&&(!isInt(rest_s)||rest_s<30||rest_s>600))e.push(`blocks[${i}].rest_s 30..600`);\n        if(intensity&&typeof intensity!==\"object\")e.push(`blocks[${i}].intensity invalid`); blocks.push(b as LiftBlock);\n      } else if(b.type===\"endurance_block\"){ const {modality,primary,value,intensity,intervals}=b; if(!isEnum(modality,EnduranceModality))e.push(`blocks[${i}].modality invalid`);\n        if(primary!==\"distance_m\"&&primary!==\"duration_s\")e.push(`blocks[${i}].primary invalid`); if(!isNum(value)||value<=0)e.push(`blocks[${i}].value > 0`);\n        if(intensity&&![\"easy\",\"moderate\",\"threshold\",\"interval\"].includes(intensity))e.push(`blocks[${i}].intensity invalid`);\n        if(intervals){ if(!Array.isArray(intervals))e.push(`blocks[${i}].intervals must be array`); else intervals.forEach((it:any,k:number)=>{ if(!isInt(it.work_s)||!isInt(it.rest_s)||!isInt(it.reps)||it.work_s<=0||it.rest_s<0||it.reps<1)e.push(`blocks[${i}].intervals[${k}] invalid`); }); }\n        blocks.push(b as EnduranceBlock);\n      } else if(b.type===\"recovery_cycle\"){ const {rounds,steps}=b; if(!isInt(rounds)||rounds<1||rounds>10)e.push(`blocks[${i}].rounds 1..10`);\n        if(!Array.isArray(steps)||steps.length<1||steps.length>6)e.push(`blocks[${i}].steps 1..6`); else steps.forEach((s:any,k:number)=>{ if(!s||typeof s!==\"object\"||!isInt(s.duration_s)||s.duration_s<10||s.duration_s>3600||typeof s.label!==\"string\")e.push(`blocks[${i}].steps[${k}] invalid`); });\n        blocks.push(b as RecoveryBlock);\n      } else if(b.type===\"mobility_block\"){ const {drills}=b; if(!Array.isArray(drills)||drills.length<1)e.push(`blocks[${i}].drills missing`); else drills.forEach((d:any,k:number)=>{ const repsOk=d.reps===undefined||(isInt(d.reps)&&d.reps>=1&&d.reps<=5); if(!d||typeof d!==\"object\"||!isInt(d.duration_s)||d.duration_s<20||d.duration_s>300||typeof d.label!==\"string\"||!repsOk)e.push(`blocks[${i}].drills[${k}] invalid`); }); blocks.push(b as MobilityBlock);\n      } else { e.push(`blocks[${i}].type must be one of lift_block|endurance_block|recovery_cycle|mobility_block`); }\n    }); return e.length?{ok:false,errors:e}:{ok:true,blocks}; }\n\n  type Equipment = Mod[]; type Rules = Record<Pattern, Partial<Record<Mod, string>>>;\n  function pickTemplateId(block:AnyBlock,equipment:Equipment,rules:Rules){ if((block as any).type!==\"lift_block\")return{reason:\"non-lift block\"}; const b=block as LiftBlock; const prefs=[b.preferred_modality,\"machine\",\"barbell\",\"dumbbell\",\"bodyweight\",\"cable\",\"kettlebell\",\"smith\",\"landmine\",\"band\"].filter(Boolean) as Mod[]; const avail=prefs.find(m=>equipment.includes(m)); if(!avail)return{reason:`no available modality for pattern=${b.pattern}`}; const id=rules[b.pattern]?.[avail]; return id?{template_id:id,reason:`pattern=${b.pattern} via ${avail}`}:{reason:`no mapping for pattern=${b.pattern} with ${avail}`}; }\n\n  function parseAndMap(rawJson:string|Record<string,any>,equipment:Equipment,rules:Rules){ let parsed:any; try{parsed=typeof rawJson===\"string\"?JSON.parse(rawJson):rawJson;}catch(e){return{ok:false,errors:[`Invalid JSON: ${String(e)}`],promptHint:buildPrompt()}} const v=validatePlan(parsed); if(!v.ok)return{ok:false,errors:v.errors,promptHint:buildPrompt()}; const warnings:string[]=[]; const mapped=v.blocks.map(b=>{ if((b as any).type!==\"lift_block\")return b; const pick=pickTemplateId(b,equipment,rules); if(!('template_id'in pick))warnings.push(pick.reason); return {...b, template_id:(pick as any).template_id}; }); return{ok:true,plan:{blocks:mapped},warnings}; }\n\n  return { buildPrompt, parseAndMap, enums:{MovementPattern,Modality,EnduranceModality} };\n}\n",
    "rules_ts": "// rules.ts – sparse mapping (expand as needed)\nexport const RULES = {\n  horizontal_press: { barbell: \"tpl_bb_flat_bench\", dumbbell: \"tpl_db_flat_press\", machine: \"tpl_machine_chest_press\" },\n  vertical_pull:   { cable: \"tpl_lat_pulldown\", bodyweight: \"tpl_pullup\", machine: \"tpl_assisted_pullup\" },\n  knee_dominant:   { machine: \"tpl_leg_press\", barbell: \"tpl_bb_back_squat\", dumbbell: \"tpl_goblet_squat\" },\n  hip_hinge:       { barbell: \"tpl_bb_rdl\", dumbbell: \"tpl_db_rdl\", machine: \"tpl_machine_hinge\" }\n  // add more patterns as you add templates\n} as const;\n",
    "api_example_ts": "// server/routes/workouts.generate.ts – example wiring\nimport { StructuredWorkoutsKit } from \"../services/structured-workouts-kit\";\nimport { RULES } from \"../services/rules\";\n\nexport async function generateWorkout(req,res){\n  const userId = req.user.id; const date = req.body.date; // YYYY-MM-DD\n  const equipment = req.user.profile?.availableEquipment || [\"machine\",\"dumbbell\",\"bodyweight\"];\n\n  const kit = StructuredWorkoutsKit();\n  const prompt = kit.buildPrompt();\n  // call your LLM with `prompt` + user profile context → returns JSON string\n  const llmJson = await callModel(prompt, req.user); // MUST be JSON-only\n\n  const result = kit.parseAndMap(llmJson, equipment, RULES as any);\n  if(!result.ok){ return res.status(400).json({ error:\"Model output invalid\", details: result.errors, promptHint: result.promptHint }); }\n\n  await db.query(\"INSERT INTO workouts(user_id,date,plan) VALUES($1,$2,$3)\", [userId, date, result.plan]);\n  return res.json({ ok:true, warnings: result.warnings, plan: result.plan });\n}\n"
  },

  "scripts": {
    "verification_script_js": "// scripts/verify_structured_workouts_migration.js\nconst fs=require('fs');const path=require('path');const ROOT=process.cwd();\nconst TARGET_FILE=path.join(ROOT,'server','services','structured-workouts-kit.ts');\nconst FORBIDDEN=[/resolveExerciseName\\b/i,/exercise-resolver(\\.v\\d+)?\\.ts/i,/levenshtein\\b/i,/jaccard\\b/i,/fuzzy\\b/i,/aliasLookup\\b/i,/normalizeExercise(Name|s)?\\b/i,/STATIC_ALIASES\\b/i,/EXPAND\\b/i];\nfunction walk(d){let r=[];for(const f of fs.readdirSync(d,{withFileTypes:true})){if(f.name.startsWith('.')||['node_modules','.git','.next','dist','build'].includes(f.name))continue;const p=path.join(d,f.name);if(f.isDirectory())r=r.concat(walk(p));else if(f.isFile())r.push(p);}return r}\nfunction scan(file){const t=fs.readFileSync(file,'utf8');return FORBIDDEN.filter(x=>x.test(t)).map(x=>x.source)}\n(function(){const all=walk(ROOT).filter(p=>/\\.(ts|tsx|js|jsx|json)$/.test(p));const offenders=[];for(const f of all){const hits=scan(f);if(hits.length)offenders.push({file:f,hits});}\nconst kitExists=fs.existsSync(TARGET_FILE);\nconst kitUsage=all.filter(f=>/\\.(ts|tsx|js)$/.test(f)).map(f=>({f,txt:fs.readFileSync(f,'utf8')})).filter(({txt})=>/StructuredWorkoutsKit/.test(txt)&&/buildPrompt|parseAndMap/.test(txt)).map(({f})=>f);\nconsole.log('--- Structured Workouts Migration Verification ---');\nconsole.log('StructuredWorkoutsKit present:',kitExists?'YES':'NO'); if(!kitExists)console.log('Expected at:',TARGET_FILE);\nif(offenders.length){console.log('\\n❌ Legacy fuzzy references:');offenders.slice(0,50).forEach(o=>{console.log('-',o.file);console.log('  hits:',o.hits.join(', '));});} else {console.log('\\n✅ No legacy fuzzy references detected.');}\nif(kitUsage.length){console.log('\\n✅ StructuredWorkoutsKit used in:');kitUsage.slice(0,50).forEach(f=>console.log('-',f));} else {console.log('\\n⚠️ Could not detect StructuredWorkoutsKit usage. Ensure you call buildPrompt/parseAndMap.');}\nconst pass=kitExists&&offenders.length===0&&kitUsage.length>0;console.log('\\nResult:',pass?'PASS ✅':'FAIL ❌');process.exit(pass?0:1);})();\n",
    "smoke_e2e_ts": "// scripts/smoke_e2e.ts – run with ts-node\nimport { StructuredWorkoutsKit } from '../server/services/structured-workouts-kit';\nimport { RULES } from '../server/services/rules';\n\n(async function(){\n  const kit = StructuredWorkoutsKit();\n  const fakeModelJson = JSON.stringify({\n    blocks:[\n      {type:'lift_block', pattern:'knee_dominant', preferred_modality:'machine', sets:4, reps:10, rest_s:120},\n      {type:'endurance_block', modality:'run', primary:'duration_s', value:1800, intensity:'easy'},\n      {type:'recovery_cycle', rounds:3, steps:[{label:'sauna',duration_s:900},{label:'ice_bath',duration_s:300}]}\n    ]\n  });\n  const equipment = ['machine','dumbbell','bodyweight'];\n  const out = kit.parseAndMap(fakeModelJson, equipment, RULES as any);\n  if(!out.ok){ console.error('Invalid:', out.errors); process.exit(1); }\n  console.log('Plan OK. Warnings:', out.warnings);\n  console.log(JSON.stringify(out.plan, null, 2));\n})();\n"
  },

  "algorithms_refactor_checklist": [
    "AI workout generator: use `kit.buildPrompt()` and `kit.parseAndMap()` → store structured JSON in `workouts.plan`",
    "Readiness-based session builder: select by pattern + equipment using RULES (no names)",
    "Daily summaries/insights: read structured blocks to compute volume/time (no names)",
    "Workout tracker UI: render by `template_id` (from RULES/exercise_templates) and block fields (sets/reps/rest)",
    "Preferences: map `availableEquipment` → equipment array fed to `parseAndMap`",
    "Delete any code that parses or normalizes exercise names"
  ],

  "runbook": [
    "1) Apply DB SQL: `drop_and_create_sql` then `seed_templates_sql`.",
    "2) Add files: structured_workouts_kit.ts, rules.ts, and the example API route wiring.",
    "3) Remove legacy files per cleanup.delete_files_glob; remove env keys.",
    "4) Wire generator endpoint to use the kit; ensure LLM returns JSON-only.",
    "5) Run smoke test: `ts-node scripts/smoke_e2e.ts` (should print a mapped plan).",
    "6) Run verifier: `node scripts/verify_structured_workouts_migration.js` (must PASS).",
    "7) Manually generate a real plan via the API; confirm UI renders all blocks.",
    "8) Commit: 'refactor: hard reset to StructuredWorkoutsKit; drop legacy workouts and fuzzy resolver'."
  ],

  "acceptance_criteria": [
    "All workout creation flows use StructuredWorkoutsKit; LLM outputs strict JSON; server validates and maps.",
    "No fuzzy logic/aliases/normalizers remain (verification script PASS).",
    "DB contains `exercise_templates` and `workouts` only (for workouts domain).",
    "Endurance/recovery/mobility blocks render without name lookups.",
    "RULES provides templates for core patterns; missing combos log warnings but do not crash.",
    "Smoke script succeeds and a real API call renders a complete session."
  ]
}
